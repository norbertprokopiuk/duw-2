%% 
% Utworzenie pustej struktury do przechowywania wiêzów w postaci ogónej
Wiezy = struct('typ',{},... % dopisanych czy kinematyczny
    'klasa',{},... % para postepowa czy obrotowa (innych na razie nie ma)
    'bodyi',{},... % numer pierwszego ciala
    'bodyj',{},... % numer drugiego ciala
    'sA',{},... % wektor sA w i-tym ukladzie
    'sB',{},... % wektor sB w j-tym ukladzie
    'phi0',{},... % kat phi0 (jezeli para obrotowa - nie uzywamy)
    'perp',{},... % wersor prostopadly osi ruch (jezeli para obrotowa - nie uzywamy)
    'fodt',{},... % funkcja od czasu dla wiezow dopisanych
    'dotfodt',{},... % pochodna funkcji od czasu dla wiezow dopisanych
    'ddotfodt',{}) % druga pochodna funkcji od czasu dla wiezow dopisanych

Bezwladnosci = struct('m',{},... % masa cz³onu (m)
    'Iz',{}) % moment bezw³adnoœci cz³onu wzglêdem osi z (I_z)

Sprezyny = struct('k',{},... % sztywnosc sprezyny
    'c',{},... % tlumienie w sprezynie
    'bodyi',{},... % numer pierwszego ciala przylozenia sprezyny
    'bodyj',{},... % numer drugiego ciala przylozenia sprezyny
    'sA',{},... % punkt przylozenia sprezyny do ciala i w i-tym ukladzie lokalnym
    'sB',{},... % punkt przylozenia sprezyny do ciala j w j-tym ukladzie lokalnym
    'd0',{}) % dlugosc swobodna sprezyny

Sily = struct('F',{},... % wektor przylozonej sily
    'bodyi',{},... % numer ciala, do ktorego przylozono sile
    'sA',{}) % punkt przylozenia sily do ciala i w i-tym ukladzie lokalnym

% Wczytanie wiêzów opisuj¹cych mechanizm
input_wiezy;
input_wymiary;
% Inicjalizacja zmiennej do wyznaczania liczby równañ wiêzów 
rows = 0;

%% PAUSE


for l=1:length(Wiezy)
    if(lower(Wiezy(l).typ(1)) == 'd')
        if(lower(Wiezy(l).klasa(1)) == 'o')
            rows = rows + 1;
        elseif(lower(Wiezy(l).klasa(1)) == 'p')
            rows = rows + 1;
        else
            error(['Blednie podana klasa dla wiezu nr ', num2str(l)]);
        end
    elseif(lower(Wiezy(l).typ(1)) == 'k')
        if(lower(Wiezy(l).klasa(1)) == 'o')
            rows = rows + 2;
        elseif(lower(Wiezy(l).klasa(1)) == 'p')
            rows = rows + 2;
        else
            error(['Blednie podana klasa dla wiezu nr ', num2str(l)]);
        end
    else
        error(['Blednie podany typ dla wiezu nr ', num2str(l)]);
    end
end

%% PAUSE

%% Ca³kowanie przy pomocy metody Rungego-Kutty rzêdu 4-5

tstart = 0;
tstop = 5;
timestep = 0.1; % Paramtery czasu ca³kowania
timespan = tstart:timestep:tstop;

M = MacierzMasowa(Bezwladnosci, NoB);

q0 = [0.7; -0.2; 0;
    0; 0.2; 0;
    0.2; 0.3; 0;
    1.55; -0.35; 0;
    0.9; 0.2; 0;
    0.2; -0.35; 0;
    0.6; -0.25; 0;
    0.15; -0.45; 0;
    0.25; 0.05; 0;
    0.7; 0; 0]; % Pocz¹tkowe po³o¿enia

qdot0 = zeros(size(q0)); % Pocz¹tkowe prêdkoœci

Y0 = [q0; qdot0]; % Wektor, który bêdzie ca³kowany

%% PAUSE

[T,Y]=ode45(@(t,Y) RHS(t,Y,Wiezy,rows,M, NoB, Bezwladnosci, NoS, Sprezyny, NoF, Sily),timespan,Y0);
    % Poniewa¿ macierz bezw³adnoœci nie zmienia siê w czasie, wiêc aby nie
    % obliczaæ jej za ka¿dym razem od nowa, jest po prostu przekazywana
    % jako argument funkcji ca³kowanej

Y = Y';    
    
timepoints = 1:( length(T) );
Ydot = zeros(size(Y));
for iter=timepoints
	Ydot(:,iter) = RHS( T(iter), Y(:,iter), Wiezy,rows,M, NoB, Bezwladnosci, NoS, Sprezyny, NoF, Sily );
end

Q = Y(1:30, :);
DQ = Y(31:60, :);
D2Q = Ydot(31:60, :);


 